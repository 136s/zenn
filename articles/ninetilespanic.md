---
title: "ボードゲームの最適解を探索してみる〈ナインタイルパニック〉"
emoji: "🍔"
type: "tech"
topics: ["python", "ゲーム", "ボードゲーム"]
published: false
---

この記事は、Oink Games から販売されている「[ナインタイルパニック](https://oinkgames.com/ja/games/analog/nine-tiles-panic/)」というゲームの最適解を探す[プログラム](https://github.com/136s/nine_tiles_panic)にまつわる備忘録です。
テクニカルな計算時間の短縮や、並列計算などは行わず、探索対象の性質を考えて全探索の数を削っています。そのため、アルゴリズムの目新しさなどはありません。

# 「いそげ、脳みそ。」

ナインタイルパニックの箱裏のキャッチコピーです。どんなゲームかを端的に表しています。
ルールの詳細は実際にゲームを買って遊ぶのが理解への近道ですが、購入するまでは[公式サイト](https://oinkgames.com/ja/games/analog/nine-tiles-panic/)の説明を読んでみてください。

簡単に言うと、

- プレイヤーは全員同じタイルを持っていて、個人戦
- 毎回ランダムで変わる 3 つのお題をなるべく満たすようにタイルを並べる
- お題ごとに点数を計算して順位を決める

という性質のゲームです。（ここに時間制限の絶妙さが入ってくるのでとても面白いです。）
なので、お題の組合せによっては 3 つ全てで最高得点を取れるのではないかと考えました。
全てのタイルの並べ方（「町」と呼びます）に対して全てのお題の点数を計算すれば、理論上は最適解が見つかるはずです。

# 結論

最適解の町が分かったらここに追記します。

## お題の得点の整理

お題カードは 26 枚あり、そこから 3 枚ランダムに選ぶので、$_{26}\mathrm{C}_3=2600$ 通りのお題設定がありえます。

`python -m nine_tiles_panic` で得られた `success_pattern.db` に対して抽出操作すればお題やお題設定の性質を知ることができます。
まずは、各お題でありうる得点とその最高得点を列挙してみました。

```sql: SQL
select distinct t01 from towns; -- お題 1 のありうる得点を抽出する
```

|お題|ありうる得点|最高得点|
|----:|:----|----:|
|1|0, 1, 2, 3, 4|4|
|2|0, 1, 2, 3, 4|4|
|3|1, 2, 3, 4, 5|5|
|4|0|0|
|5|1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11|11|
|6|1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11|11|
|7|1, 2, 3, 4, 5, 6|6|
|8|0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20|20|
|9|0, 1, 2, 3, 4, 5|5|
|10|1, 2, 3, 4, 5, 6|6|
|11|0, 1, 2, 3|3|
|12|1, 2, 3, 4, 5, 6|6|
|13|1, 2, 3, 4, 5|5|
|14|0, 1, 2, 3, 4|4|
|15|-6, -5, -4, -3, -2, -1|-1|
|16|0, 1, 2, 3, 4, 5, 6, 7|7|
|17|0, 1, 2, 3, 4, 6, 8|8|
|18|0, 1, 2, 3, 4|4|
|19|0, 1, 2, 3, 4|4|
|20|0, 1, 2, 3|3|
|21|1, 2, 3, 4, 5, 6, 7, 8, 9|9|
|22|0, 1, 2, 3, 4, 5, 6|6|
|23|1, 2, 3, 4, 5|5|
|24|0, 1, 2, 3, 4, 5|5|
|25|0, 1, 2, 3|3|
|26|0, 1, 2, 3, 4|4|

次に、26 のお題全てが同じ得点となるような "お題シノニム theme synonym" を作ります。

```sql: SQL
create table points as select rowid as id, count(*) as num_towns, t01, t02, t03, t04, t05, t06, t07, t08, t09, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26 from towns group by t01, t02, t03, t04, t05, t06, t07, t08, t09, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26;
```

# 探索アルゴリズムを考える

愚直な順に 3 種類列挙します。各アルゴリズムの最後に、パターンとその点数を出力するコードを記載します。

## アルゴリズム A：全探索

まず素直に思いつくのは全パターンの探索です。9 枚のタイルそれぞれの表裏 ($8^2$) と角度 ($8^4$) と、そのタイルの置き場所 ($9!$) の積の 48,704,929,136,640 通りが愚直な数です。
この探索プログラムを書き始めた当初（2022 年 9 月）は町が完成できるかどうかだけ探索していました。しかし筆者の環境では秒速 2700 通り程度しか探索できず、単純計算で約 572 年 (!) なのでコンピュータお姉さんになっていまいます。

```python
from nine_tiles_panic import Search, Town
for pattern in Search.search_all():
    points = Town(pattern).get_theme_point()
    print(pattern, points)
```

## アルゴリズム B：道の形状だけ先に探索する

次に思いついたのは、道の形状だけに着目して町を完成できるか探索し、その次にタイルを当てはめていくという手順です。
アルゴリズム C は点数計算の省力化なので、現時点での町の探索法はこれが最短です。
コード中では、道の形状が同じタイルを "道シノニム road synonym"、道の形状が同じ町を "町シノニム town synonym" と書いています（今考えれば、前者は "タイルシノニム tile synonym" が相応しかった…）。
ちなみに完成している町とは、公式サイトによると

> ３✕３の範囲の中で自由に入れ替え、向きを変えたり、裏返したりして、きちんと道がつながった町

のことで、実際はこれに加えて、町の中で閉路を作ってはいけないという条件があります。

探索上の工夫としては、各タイルや町全体を回転して道の形状が同じになるパターンを除外しました。また、元のタイルの表裏を合わせても足りない枚数の組合せになる町シノニムも除外しました。
探索の結果、このパターンは（コードが正しければ）63,660 通り[（一覧）](https://github.com/136s/nine_tiles_panic/blob/main/tests/expected/synonym_pattern.txt)です。筆者の環境では 20 h 弱で探索が終わりました。

```python
from nine_tiles_panic import Search
for _ in Search.search_synonym("synonym_pattern.txt"):
    pass
```

ここで、このプログラムにおける町パターンの記述方法を説明します。
町パターンの記法は、18 桁の 0-9 からなる数字列で、前半 (position) と後半 (direction) に分かれます。
例えば、町シノニムの `224221113000100031` は次のコードから生成できる以下の形状です。

```python
from nine_tiles_panic import Tile, Town, View
View(Town("224221113000100031", Tile.get_synonym())).draw()
```

!["tow synonym: 224221113000100031"](https://raw.githubusercontent.com/136s/nine_tiles_panic/main/tests/expected/224221113000100031_p.png)

説明のためにタイル位置の番号も描画します。タイルの左上で `[]` 書きされているのが位置番号です。（裸の 0-3 の数字は、後述する道の辺番号です。）

```python
from nine_tiles_panic import Tile, Town, View
View(Town("224221113000100031", Tile.get_synonym()), view_number=True).draw()
```

!["tow synonym with number: 224221113000100031"](/images/224221113000100031_p_n.png)

前半の `224221113` は、その index にあるタイルの種類を表しています。例えば 0 桁目の `2` は、曲線が 2 つあるタイルが 0 番目の位置（町の左上）にあることを表しています。
道シノニムの番号はプログラム中の `Tile.get_synonym()` で定義されていますが、図示すると以下の 5 種類です。十の位がタイルの種類です。

![road synonyms](/images/road_synonyms.png)

後半の `000100031` は、その index にあるタイルの方向を示しています。`0` は上図の向きで、1 増える毎に左に 90 度ずつ回転することを表します。例えば、3 桁目の `1` は、3 番目の位置（町の左）にある `2` のタイルが `1` の向き、即ち左 90 度回転していることを表しています。

町パターンの記法はここまでです。
こうして "生成可能な" 町シノニムのパターンが得られたので、あとは元のタイルセットの表裏の組合せを考慮して "実際に" 作れる町かどうかを判定すればいいことになります。

上で得られた `synonym_pattern.txt` を基に以下のコードで生成可能な町とその点数を計算できます。
ここでの探索の工夫は、タイル上のオブジェクトを考慮して、確実に同じ点数になるタイルの向きを除外しました。得点計算に関わるオブジェクトの性質は次の 3 つです。

- 道の向きとオブジェクトの向きが関係する：エージェント（道の上）、宇宙人（道の上）
- 道の向きのみ関係する：ハンバーガー
- 向きは関係しない：犬、市民（女の子）、市民（男の子）、家、UFO、エージェント（道の外）、宇宙人（道の外）

探索の結果、実際に完成できる町は（コードが正しければ）526,070,976 通りです。

```python
from nine_tiles_panic import Search
with open("synonym_pattern.txt") as f:
    for line in f:
        pattern_synonym = line.split("\n")[0]
        for pattern, points in Search.search_point_from_synonym(pattern_synonym):
            print(pattern, points)
```

## アルゴリズム C：道シノニムと、元のタイルとで段階を踏んで点数計算する

3 つめのアルゴリズムは、得点計算を段階的に計算することで計算時間を短縮しました。
得点計算の観点から、お題の性質は次の 4 つに分類できます。

1. 道の上のオブジェクトから計算する：「宇宙人をつかまえた数が多い」など
2. タイルの上の道の外のオブジェクトから計算する：「犬の数が多い」など
3. 道の形状から計算する：「カーブの数が多い」など
4. タイルに関係ない：「町を完成させるのが早い」

そのため、4. のお題は 0 点で固定、町シノニムで 3. のお題を計算して、タイルが変わらない間は 2. のお題を計算して、残りの 1. のお題を毎回の町で計算すれば計算量が削減できます。

```python
from nine_tiles_panic import Search
for pattern, points in Search.search_point_2():
    print(pattern, points)
```
