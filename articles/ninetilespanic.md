---
title: "ボードゲームの最適解を探索してみる〈ナインタイルパニック〉"
emoji: "🍔"
type: "tech"
topics: ["python", "ゲーム", "ボードゲーム"]
published: false
---

この記事は、Oink Games から販売されている「[ナインタイルパニック](https://oinkgames.com/ja/games/analog/nine-tiles-panic/)」というゲームの最適解を探す[プログラム](https://github.com/136s/nine_tiles_panic)にまつわる備忘録です。
テクニカルな計算時間の短縮や、並列計算などは行わず、探索対象の性質を考えて全探索の数を削っています。

# 「いそげ、脳みそ。」

ナインタイルパニックの箱裏のキャッチコピーです。どんなゲームかを端的に表しています。
ルールの詳細は実際にゲームを買って遊ぶのが理解への近道ですが、購入するまでは[公式サイト](https://oinkgames.com/ja/games/analog/nine-tiles-panic/) の説明を読んでみてください。

簡単に言うと、

- プレイヤーは全員同じタイルを持っていて、個人戦
- 毎回ランダムで変わる 3 つのお題をなるべく満たすようにタイルを並べる
- お題ごとに点数を計算して順位を決める

という性質のゲームです。（ここに時間制限の絶妙さが入ってくるのでとても面白いです。）
なので、お題の組合せによっては 3 つ全てで最高得点を取れるのではないかと考えました。
全てのタイルの並べ方（「町」と呼びます）に対して全てのお題の点数を計算すれば、理論上は最適解が見つかるはずです。

## 結論

お題カードは 26 枚あり、そこから 3 枚ランダムに選ぶので、$_{26}\mathrm{C}_3=2600$ 通りのお題設定がありえます。
記事執筆時点では全ての町に対して点数計算をしている段階ですが、計算が終わり次第この節に追記します。
計算してくれる方は、[GitHub](https://github.com/136s/nine_tiles_panic) にコード置いてるので実行してみてください。筆者の環境では 0 から点数計算始めると 2 週間以上はかかります。

# 探索アルゴリズムを考える

愚直な順に 3 種類列挙します。各アルゴリズムの最後に、パターンとその点数を出力するコードを記載します。

## アルゴリズム A：全探索

まず素直に思いつくのは全パターンの探索です。9 枚のタイルそれぞれの表裏 ($8^2$) と角度 ($8^4$) と、そのタイルの置き場所 ($9!$) の積の 48,704,929,136,640 通りが愚直な数です。
この探索プログラムを書き始めた当初（2022 年 9 月）は町が完成できるかどうかだけ探索していました。しかし筆者の環境では秒速 2700 通り程度しか探索できず、単純計算で約 572 年 (!) なのでコンピュータお姉さんになっていまいます。

```python
from nine_tiles_panic import Search, Town
for pattern in Search.search_all():
    points = Town(pattern).get_theme_point()
    print(pattern, points)
```

## アルゴリズム B：道の形状だけ先に探索する

次に思いついたのは、道の形状だけに着目して町を完成できるか探索し、その次にタイルを当てはめていくという手順です。
アルゴリズム C は点数計算の省力化なので、現時点での町の探索法はこれが最短です。
コード中では、道の形状が同じタイルを "道シノニム road synonym"、道の形状が同じ町を "町シノニム town synonym" と書いています（今考えれば、前者は "タイルシノニム tile synonym" が相応しかった…）。
ちなみに完成している町とは、公式サイトによると

> ３✕３の範囲の中で自由に入れ替え、向きを変えたり、裏返したりして、きちんと道がつながった町

のことで、実際はこれに加えて、町の中で閉路を作ってはいけないという条件があります。

探索上の工夫としては、各タイルや町全体を回転して道の形状が同じになるパターンを除外しました。また、元のタイルの表裏を合わせても足りない枚数の組合せになる町シノニムも除外しました。
探索の結果、このパターンは（コードが正しければ）63,660 通り[（一覧）](https://github.com/136s/nine_tiles_panic/blob/main/tests/expected/synonym_pattern.txt)です。筆者の環境では 20 h 弱で探索が終わりました。
```python
from nine_tiles_panic import Search
for _ in Search.search_synonym("synonym_pattern.txt"):
    pass
```

ここで、このプログラムにおける町パターンの記述方法を説明します。
町パターンの記法は、18 桁の 0-9 からなる数字列で、前半 (position) と後半 (direction) に分かれます。
例えば、町シノニムの `224221113000100031` は次のコードから生成できる以下の形状です。

```python
from nine_tiles_panic import Tile, Town, View
View(Town("224221113000100031", Tile.get_synonym())).draw()
```

!["tow synonym: 224221113000100031"](https://raw.githubusercontent.com/136s/nine_tiles_panic/main/tests/expected/224221113000100031_p.png)

説明のためにタイル位置の番号も描画します。タイルの左上で `[]` 書きされているのが位置番号です。（裸の 0-3 の数字は、後述する道の辺番号です。）

```python
from nine_tiles_panic import Tile, Town, View
View(Town("224221113000100031", Tile.get_synonym()), view_number=True).draw()
```

!["tow synonym with number: 224221113000100031"](/images/224221113000100031_p_n.png)

前半の `224221113` は、その index にあるタイルの種類を表しています。例えば 0 桁目の `2` は、曲線が 2 つあるタイルが 0 番目の位置（町の左上）にあることを表しています。
道シノニムの番号はプログラム中の `Tile.get_synonym()` で定義されていますが、図示すると以下です。十の位がタイルの種類です。

![road synonyms](/images/road_synonyms.png)

後半の `000100031` は、その index にあるタイルの方向を示しています。`0` は上図の向きで、1 増える毎に左に 90 度ずつ回転することを表します。例えば、3 桁目の `1` は、3 番目の位置（町の左）にある `2` のタイルが `1` の向き、即ち左 90 度回転していることを表しています。

町パターンの記法はここまでです。
こうして "生成可能な" 町シノニムのパターンが得られたので、あとは元のタイルセットの表裏の組合せを考慮して "実際に" 作れる町かどうかを判定すればいいことになります。

上で得られた `synonym_pattern.txt` を基に以下のコードで生成可能な町とその点数を計算できます。
探索の結果、実際に完成できる町は（コードが正しければ）526,070,976 通りです。

```python
from nine_tiles_panic import Search
with open("synonym_pattern.txt") as f:
    for line in f:
        pattern_synonym = line.split("\n")[0]
        for pattern, points in Search.search_point_from_synonym(pattern_synonym):
            print(pattern, points)
```

## アルゴリズム C：道シノニムと、元のタイルとで段階を踏んで点数計算する
